/**
 * @file firestore.rules
 * @description Security rules for a Texas Hold'em poker tournament management application.
 *
 * ## Core Philosophy
 * This ruleset establishes a clear security boundary between publicly accessible tournament data and private user-specific data. All global tournament-related information (tournaments, timers, prize pools) is publicly readable to allow any user or client to view ongoing or past events. However, write access to this public data is currently restricted, pending schema updates to include ownership information. User-specific data is strictly locked down, accessible only by the owning user.
 *
 * ## Data Structure
 * The data is organized into several top-level collections:
 * - `/tournaments`: Publicly readable tournament information.
 * - `/timer_settings`: Publicly readable timer configurations. Contains a `blind_levels` subcollection.
 * - `/prize_pools`: Publicly readable prize and payout details.
 * - `/users`: Private documents for each user, secured by user ID.
 *
 * ## Key Security Decisions
 * - **Public Read-Only Data**: Collections like `/tournaments` are public for read operations (`get`, `list`) but writes are disabled. This is a secure default because the data models lack an `ownerId` or `creatorId` field, making it impossible to verify who is authorized to modify a document. A TODO comment guides the developer to add this field to enable writes.
 * - **Strict User Ownership**: The `/users/{userId}` path is governed by a strict ownership model. Only the authenticated user matching the `{userId}` wildcard can read, create, update, or delete their own document.
 * - **No User Enumeration**: Listing documents in the top-level `/users` collection is explicitly disallowed to protect user privacy and prevent data scraping.
 *
 * ## Denormalization for Authorization
 * To create simple, performant, and secure rules, it is critical that any document that requires owner-only write access contains a denormalized ownership field (e.g., `creatorId: "user-abc"`). This ruleset anticipates this pattern for collections like `/tournaments` and will block writes until such a field is present in the schema, thus avoiding slow and costly `get()` calls to other documents for authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function getUserRole(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role;
    }
    
    function isSuperAdmin(userId) {
      return getUserRole(userId) == 'super_admin';
    }

    function isAdmin(userId) {
      let userRole = getUserRole(userId);
      return userRole == 'admin' || userRole == 'super_admin';
    }

    // --------------------------------
    // Collection Rules
    // --------------------------------

    match /users/{userId} {
      // Any signed-in user can read another user's profile.
      // Admins can list all users.
      // Only the owner can create their own profile.
      // Super admins can change any role. Admins can change roles of players.
      // Owners can update their own profile, but cannot change their own role.
      // Owners and super admins can delete users.
      allow read: if isSignedIn();
      allow list: if isAdmin(request.auth.uid);
      allow create: if isOwner(userId);
      allow update: if (isSuperAdmin(request.auth.uid)) ||
                       (isAdmin(request.auth.uid) && resource.data.role != 'super_admin') ||
                       (isOwner(userId) && request.resource.data.role == resource.data.role);
      allow delete: if isOwner(userId) || isSuperAdmin(request.auth.uid);
    }
    
    match /cashGames/{gameId} {
      // Anyone signed in can view a cash game.
      allow get: if isSignedIn();
      allow list: if isSignedIn();

      // Only authenticated admins can create a new cash game.
      allow create: if isAdmin(request.auth.uid);
      
      // An admin/owner can update anything.
      // Any signed in user can add a request to join.
      allow update: if (isAdmin(request.auth.uid) || isOwner(resource.data.ownerId)) ||
                       (isSignedIn() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['requests']));
      
      // Only the owner or an admin can delete the game
      allow delete: if isAdmin(request.auth.uid) || isOwner(resource.data.ownerId);
    }

    match /tournaments/{tournamentId} {
      allow get, list: if true;
      allow create: if false; 
      allow update: if false;
      allow delete: if false;
    }

    match /timer_settings/{timerSettingsId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;

      match /blind_levels/{blindLevelId} {
        allow get, list: if true;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
      }
    }

    match /prize_pools/{prizePoolId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
