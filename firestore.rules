/**
 * Core Philosophy: This ruleset establishes a secure "read-only" environment for authenticated users.
 * Any signed-in user can view all tournament, round, and payout structure data, which is suitable for
 * an application where tournament information is public to its user base. Write operations (create, update, delete)
 * are explicitly disabled across the board as a critical security measure.
 *
 * Data Structure: The data is organized hierarchically under a top-level `tournaments` collection.
 * Each tournament document can contain `rounds` and `payoutStructures` subcollections, creating a clear
 * and logical data hierarchy.
 *
 * Key Security Decisions:
 * - Authenticated Read-Only: All data is readable by any user who is signed in. Unauthenticated users have no access.
 * - Writes Disabled by Default: All write operations are currently disallowed because the data models (e.g., 'Tournament')
 *   lack an 'ownerId' or 'creatorId' field. This prevents unauthorized data modification. To enable writes, the
 *   application's data model must be updated to include an ownership field, and these rules must be revised
 *   to check that the user performing the write is the owner.
 * - No User Listing: The ruleset does not include a `/users` collection, naturally preventing the listing of application users.
 *
 * Denormalization for Authorization: While not currently used due to disabled writes, the recommended pattern is
 * to add an `ownerId` field to the `Tournament` documents. This would allow for simple, performant rules
 * like `isOwner(resource.data.ownerId)` to secure all write operations for a tournament and its subcollections.
 *
 * Structural Segregation: This pattern is not currently required as there is no mixed private/public data
 * within any single collection. All data is treated as public for authenticated users.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Top-level collection for all poker tournaments.
     * @path /tournaments/{tournamentId}
     * @allow (get, list) - An authenticated user can read any tournament's details.
     * @deny (create, update, delete) - Any user attempting to write, because the schema is missing an ownership field.
     * @principle Public read for authenticated users, with writes disabled until a secure ownership model is implemented.
     */
    match /tournaments/{tournamentId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      // CRITICAL: Cannot implement owner-only writes. The 'Tournament' entity is missing an 'ownerId' or 'creatorId' field.
      // This prevents the rules from verifying who is authorized to create, modify, or delete a tournament.
      // To enable writes, add an ownership field to the Tournament data model and update the rules below.
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field (e.g., request.resource.data.ownerId == request.auth.uid).
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field (e.g., resource.data.ownerId == request.auth.uid).
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field (e.g., resource.data.ownerId == request.auth.uid).

      /**
       * @description Stores the blind structure and duration for each round within a tournament.
       * @path /tournaments/{tournamentId}/rounds/{roundId}
       * @allow (get, list) - An authenticated user can read the rounds for any tournament.
       * @deny (create, update, delete) - Any user attempting to write, because the parent tournament lacks an ownership model.
       * @principle Inherits the security posture of its parent. Read access is for authenticated users, and writes are disabled.
       */
      match /rounds/{roundId} {
        allow get: if isSignedIn();
        allow list: if isSignedIn();
        // CRITICAL: Writes to subcollections must be authorized by checking ownership on the parent document.
        // Since the parent /tournaments/{tournamentId} document lacks an ownership field, writes must be disabled here as well.
        allow create: if false; // TODO: Use get() to check ownership on the parent tournament document once it has an ownerId field.
        allow update: if false; // TODO: Use get() to check ownership on the parent tournament document once it has an ownerId field.
        allow delete: if false; // TODO: Use get() to check ownership on the parent tournament document once it has an ownerId field.
      }

      /**
       * @description Stores the prize pool distribution for a tournament.
       * @path /tournaments/{tournamentId}/payoutStructures/{payoutStructureId}
       * @allow (get, list) - An authenticated user can read the payout structure for any tournament.
       * @deny (create, update, delete) - Any user attempting to write, because the parent tournament lacks an ownership model.
       * @principle Inherits the security posture of its parent. Read access is for authenticated users, and writes are disabled.
       */
      match /payoutStructures/{payoutStructureId} {
        allow get: if isSignedIn();
        allow list: if isSignedIn();
        // CRITICAL: Writes to subcollections must be authorized by checking ownership on the parent document.
        // Since the parent /tournaments/{tournamentId} document lacks an ownership field, writes must be disabled here as well.
        allow create: if false; // TODO: Use get() to check ownership on the parent tournament document once it has an ownerId field.
        allow update: if false; // TODO: Use get() to check ownership on the parent tournament document once it has an ownerId field.
        allow delete: if false; // TODO: Use get() to check ownership on the parent tournament document once it has an ownerId field.
      }
    }
  }
}