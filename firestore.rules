/**
 * @file firestore.rules
 * @description Security rules for a Texas Hold'em poker tournament management application.
 *
 * ## Core Philosophy
 * This ruleset establishes a clear security boundary between publicly accessible tournament data and private user-specific data. All global tournament-related information (tournaments, timers, prize pools) is publicly readable to allow any user or client to view ongoing or past events. However, write access to this public data is currently restricted, pending schema updates to include ownership information. User-specific data is strictly locked down, accessible only by the owning user.
 *
 * ## Data Structure
 * The data is organized into several top-level collections:
 * - `/tournaments`: Publicly readable tournament information.
 * - `/timer_settings`: Publicly readable timer configurations. Contains a `blind_levels` subcollection.
 * - `/prize_pools`: Publicly readable prize and payout details.
 * - `/users`: Private documents for each user, secured by user ID.
 *
 * ## Key Security Decisions
 * - **Public Read-Only Data**: Collections like `/tournaments` are public for read operations (`get`, `list`) but writes are disabled. This is a secure default because the data models lack an `ownerId` or `creatorId` field, making it impossible to verify who is authorized to modify a document. A TODO comment guides the developer to add this field to enable writes.
 * - **Strict User Ownership**: The `/users/{userId}` path is governed by a strict ownership model. Only the authenticated user matching the `{userId}` wildcard can read, create, update, or delete their own document.
 * - **No User Enumeration**: Listing documents in the top-level `/users` collection is explicitly disallowed to protect user privacy and prevent data scraping.
 *
 * ## Denormalization for Authorization
 * To create simple, performant, and secure rules, it is critical that any document that requires owner-only write access contains a denormalized ownership field (e.g., `creatorId: "user-abc"`). This ruleset anticipates this pattern for collections like `/tournaments` and will block writes until such a field is present in the schema, thus avoiding slow and costly `get()` calls to other documents for authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function getUserRole(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role;
    }
    
    function isSuperAdmin(userId) {
      // Check if user has a super_admin role in their user document
      return isSignedIn() && getUserRole(userId) == 'super_admin';
    }

    function isAdmin(userId) {
      if (!isSignedIn()) { return false; }
      let userRole = getUserRole(userId);
      return userRole == 'admin' || userRole == 'super_admin';
    }

    // --------------------------------
    // Collection Rules
    // --------------------------------

    match /users/{userId} {
      // A user can only create their own user document.
      allow create: if isOwner(userId);
      
      // Any authenticated user can read any profile (e.g. to see names). List is restricted.
      allow get: if isSignedIn();
      // Only admins can list all users for the admin panel.
      allow list: if isAdmin(request.auth.uid);
      
      // A user can update their own profile, but cannot change their own role.
      // A Super Admin can update any profile, including roles.
      // An Admin can update any profile, but cannot make someone a Super Admin or change another Admin.
      allow update: if (isOwner(userId) && request.resource.data.role == resource.data.role) ||
                       (isSuperAdmin(request.auth.uid)) ||
                       (isAdmin(request.auth.uid) && resource.data.role == 'player' && request.resource.data.role != 'super_admin');

      // Owner or Super Admin can delete a user account document.
      allow delete: if isOwner(userId) || isSuperAdmin(request.auth.uid);
    }
    
    match /cashGames/{gameId} {
      // Anyone signed in can view a cash game.
      allow get: if isSignedIn();
      allow list: if isSignedIn();

      // Only authenticated admins can create a new cash game.
      allow create: if isAdmin(request.auth.uid);
      
      // An admin/owner can update anything.
      // Any signed in user can add a request to join by updating the `requests` array.
      allow update: if (isAdmin(request.auth.uid) || isOwner(resource.data.ownerId)) ||
                       (isSignedIn() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['requests']));
      
      // Only the owner or an admin can delete the game
      allow delete: if isAdmin(request.auth.uid) || isOwner(resource.data.ownerId);
    }

    match /tournaments/{tournamentId} {
      allow get, list: if true;
      allow create: if false; 
      allow update: if false;
      allow delete: if false;
    }

    match /timer_settings/{timerSettingsId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;

      match /blind_levels/{blindLevelId} {
        allow get, list: if true;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
      }
    }

    match /prize_pools/{prizePoolId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
