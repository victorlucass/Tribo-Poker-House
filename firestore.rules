/**
 * @file firestore.rules
 * @description Security rules for a Texas Hold'em poker tournament management application.
 *
 * ## Core Philosophy
 * This ruleset establishes a clear security boundary between publicly accessible tournament data and private user-specific data. All global tournament-related information (tournaments, timers, prize pools) is publicly readable to allow any user or client to view ongoing or past events. However, write access to this public data is currently restricted, pending schema updates to include ownership information. User-specific data is strictly locked down, accessible only by the owning user.
 *
 * ## Data Structure
 * The data is organized into several top-level collections:
 * - `/tournaments`: Publicly readable tournament information.
 * - `/timer_settings`: Publicly readable timer configurations. Contains a `blind_levels` subcollection.
 * - `/prize_pools`: Publicly readable prize and payout details.
 * - `/users`: Private documents for each user, secured by user ID.
 *
 * ## Key Security Decisions
 * - **Public Read-Only Data**: Collections like `/tournaments` are public for read operations (`get`, `list`) but writes are disabled. This is a secure default because the data models lack an `ownerId` or `creatorId` field, making it impossible to verify who is authorized to modify a document. A TODO comment guides the developer to add this field to enable writes.
 * - **Strict User Ownership**: The `/users/{userId}` path is governed by a strict ownership model. Only the authenticated user matching the `{userId}` wildcard can read, create, update, or delete their own document.
 * - **No User Enumeration**: Listing documents in the top-level `/users` collection is explicitly disallowed to protect user privacy and prevent data scraping.
 *
 * ## Denormalization for Authorization
 * To create simple, performant, and secure rules, it is critical that any document that requires owner-only write access contains a denormalized ownership field (e.g., `creatorId: "user-abc"`). This ruleset anticipates this pattern for collections like `/tournaments` and will block writes until such a field is present in the schema, thus avoiding slow and costly `get()` calls to other documents for authorization.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function getUserRole(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role;
    }

    function isSuperAdmin() {
      // The super admin is defined by their email in an environment variable.
      // We check the 'name' field which corresponds to the email in the auth token.
      return request.auth.token.email == resource.data.superAdminEmail;
    }

    function isAdmin() {
      return getUserRole(request.auth.uid) == 'admin';
    }

    // --------------------------------
    // Collection Rules
    // --------------------------------

    match /users/{userId} {
      allow read: if isSignedIn();
      allow list: if isAdmin();
      allow create: if isOwner(userId);
      // Only an admin can change a user's role, but users can update their own profile.
      allow update: if isAdmin() || (isOwner(userId) && request.resource.data.role == resource.data.role);
      allow delete: if isOwner(userId);
    }
    
    match /cashGames/{gameId} {
      // Anyone can read a cash game's data to see the details
      allow get: if isSignedIn();
      allow list: if isSignedIn();

      // Only authenticated users can create a new cash game
      // The ownerId in the document must match the creator's UID
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      
      // Only the owner or an admin can update the game state
      allow update: if isSignedIn() && (isOwner(resource.data.ownerId) || isAdmin());
      
      // Only the owner can delete the game
      allow delete: if isSignedIn() && isOwner(resource.data.ownerId);
    }

    match /tournaments/{tournamentId} {
      allow get, list: if true;
      allow create: if false; 
      allow update: if false;
      allow delete: if false;
    }

    match /timer_settings/{timerSettingsId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;

      match /blind_levels/{blindLevelId} {
        allow get, list: if true;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
      }
    }

    match /prize_pools/{prizePoolId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
